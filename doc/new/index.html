<html >
	<head>
	<title>Libpgen Document</title>	

	<link rel="stylesheet" type="text/css" href="style.css">
	</head>

		<body>


<h1>LIBPGEN Official Document</h1>
Author: slank (<a href=https://twitter.com/slankdev>@slankdev</a>)<br>
E-mail: <a href="mailto: slank.dev@gmail.com">slank.dev@gmail.com</a><br>
Web-site: <a href=http://slankdev.net/libpgen>http://slankdev.net/libpgen</a><br>
Update: 2015/09/16 <br>

<hr></hr>

<h2 class="title">はじめに</h2>

<div>
<p>まずはじめに、このドキュメントを読んでくださり、ありがとうございます。
筆者は2015年の春からこのライブラリを開発しはじめています。はじめはローカルネットワークで
ARPスキャンをするプログラムの拡張用で適当に書いたんですけど、機能を追加するうちにだんだん
楽しく感じてきて、いまでは暇つぶし兼ライフワークになっています。
また、ネットワークのプロトコルの知識を深めるいい環境として捉えています。</p>
<p>このライブラリは現在、一人で開発しているのですが、セキュリティキャンプ講師の方、2015年度全国大会卒業生の方
をはじめ、たくさんの方にアイディアや助言をいただいております。誠にありがとうございます。
今後とも宜しくお願いします。</p>

<h3>開発者について</h3>
このライブラリはslank(slank.dev@gmail.com)が開発を行っています。libpgenを気に入ってくれた方や、開発に参加したい、
と感じてくれた方は開発者まで連絡をお願いします。
まだ未熟な大学生ですが、libpgenを良いライブラリにしていけたら良いと考えています。

<h3>ライセンス</h3>
このライブラリのライセンスはGNU GPLとしています。いかなる場合でも、このライブラリを使用しておきた不具合等に
関しての責任は負いかねます。
様々なパケットを生成し、送信することが可能なので、実験は必ず自己環境で行ってください。
不用意に作成したパケットを送信してしまうと、ネットワークや別のコンピュータに対しての攻撃になってしまう場合が
ありますので、最初はpcapファイル書き出してwiresharkなどでデバッグしていくことをお勧めします。
 
<h3>このドキュメントを書く参考にしたサイト</h3>
Producing Open Source Software (http://producingoss.com) <br>
TCPDUMP &amp; LIBPCAP (http://www.tcpdump.org/) <br> 
</div>	

<h2 class="title">目次</h2>
<div>
	<ul>
		<li><a href=#discription>概要</a></li>
		<li><a href=#install>インストール方法</a></li>
		<li><a href=#sample>サンプルプログラム</a></li>
		<li><a href=#components>libpgenの基本機能</a></li>
		<li><a href=#programing>プログラミングの流れ</a></li>
		<li><a href=#extention>拡張する</a></li>
	</li>
</div>



<h2 class="title"><a name=discription>概要</a></h2>
<div>

<h3>libpgen(library packet generator)とは</h3>
<p>libpgenはC++で簡単にパケットを作成、送受信、解析することができるライブラリです。
開発初期はパケット送信機能のみの実装だったためpacket generatorという名前になってしまいました。
ネットワークプログラミングに精通していなくても、ネットワークの基本的な知識があればこのライブラリを使用して、
様々なネットワークテストを行うことができます。
libpgenはネットワークプログラミング入門から高度な（低レイヤ）ネットワークプログラミングのツール作成までを
補助することを目標としています。</p>
<p>また新たなプロトコルに簡単に対応できるようにしていて、簡単に開発に参加することようにしています。
このライブラリは2015年09月10日現在、Ethernet, ARP, IP, ICMP, TCP, UDP, DNS, DHCP, ar_droneに対応しています。
今後も多数のプロトコルや拡張機能を追加していきます。</p>


<h3>必要な最低限度の知識</h3>
C/C++の基本的な文法（別にポインタがどうとかややこしい話は全く出てきません）
ネットワーク関連の基本的な知識。ICMPの基本的な部分を理解していれは、このライブラリを仕様して簡単なpingコマンドを
書くことはすぐにできるでしょう。


<h3>実行可能環境</h3>
Linuxで実行可能です。筆者はUbuntuGnome14.04LTSとArchLinuxで実行確認をしました。
現在はLinuxのみをサポートしていますが、今後OSX, BSD系のOSにも対応予定です。
実行マシンでgitがインストールされていればlibpgenのインストール、開発を円滑に進めることができます。

</div>	





<h2 class="title"><a name=install>インストール方法</a></h2>
<div>

<p>まずはlibpgenをインストールしてみましょう。普通のLinux環境であればインストールは簡単にでき、
すぐに使い始めることができるはずです。</p>

<h3>1. ビルド、インストールに必要なパッケージをインストール</h3>
<p>libpgenをビルドするには以下のパッケージが最低でも必要です。使用環境に合わせてインストールしてください。</p>
<p>
g++ version 0.0.0 以降<br>
make version 0.0.0 以降<br>
ar version 0.0.0 以降<br>
</p>

ubuntuやdebian系なら<br>
<pre>	# apt-get install g++ make ar </pre>

Cent OSやFedoraなどのRHEL系なら<br>
<pre>	# yum install g++ make ar </pre>



<h3>2. ソースコードをダウンロード</h3>
<p>libpgenのソースをGitHubの李モードリポジトリで管理しているので、
git cloneをつかえば簡単にソースを入手することができます。</p>
<pre>$ git clone https://github.com/slankdev/libpgen.git  </pre>

<p>もしGitを導入していない場合は、
<a href=http://slankdev.net/libpgen/file.tar.gz>GitHubのlibpgenのページ</a>からパッケージをダウンローして、
任意のディレクトリに展開します。


<h3>3. makeとインストール</h3>
<p>srcディレクトリに移動してmakeを実行してビルドします。makeが完了したらmake installでlibpgenをインストールします。
make installは管理者権限を仕様して実行してください。</p>

<pre>
	$ cd libpgen
	$ make
	$ sudo make install
</pre>

<p>これでlibpgenを使って開発を行う準備が整いました。
もしlibpgenを完全にアンインストールしたい場合はsrcディレクトリに移動して以下のコマンドを実行します。</p>

<pre>
	$ cd libpgen
	$ make uninstall
</pre>

<p>このコマンドを実行すればlibpgenに関するすべてのファイルを消去して、libpgenをアンインストールすることができます。</p>




</div>
<h2 class="title"><a name=sample>サンプルプログラミング</a></h2>
<div>

<p>インストールが完了したら、libpgenを使って簡単なプログラムを書いていきましょう。
実際にlibpgenを使って開発などを行う前にパケットキャプチャ、pingコマンドの作成は経験しておくことををお勧めします。</p>
<p>現段階ではこのサンプルコードが何を言っているのかは理解できなくても、何も問題ありません。
libpcapを使ったことがあったり、ネットワークのプロトコルの知識がすこしあれば察しがつく方もいるかもしれませんが、
詳細に理解する必要はないので、安心してください。雰囲気でいいのです。</p>
<p>現在はパケットキャプチャとpingコマンドのみですが、今後もサンプルの追加をしていく予定です。</p>

<strong>[パケットキャプチャ] <a href=./sample/packet-capture.html>サンプルコード</a><br></strong>
<p>libpgenのパケット受信機能と、パケット解析機能を使って簡単なパケットキャプチャを作成します。
30行ほどのコードでL4まで簡単に解析をするパケットキャプチャを作成することができます。
今後に説明する高度なプロトコル解析機能を使えばさらに高度なパケットキャプチャにパワーアップさせたり、
pcapファイルに保存する機能を追加することもできます。</p>



<strong>[pingコマンド] <a href=./sample/ping.html>サンプルコード</a><br></strong>
<p>パケットキャプチャの作成で、パケットの受信機能と簡単な解析を習得することができました。
次は、パケットの送信ともう少し詳しく解析をするプログラムを作成します。</p>
<p>pingコマンドは誰も使ったことがあるコマンドだと思います。実際に使われるpingコマンドはホスト名からIPアドレスに
名前解決を行ったり、失敗時の情報をまとめたり、色々な機能がありますが、ここで作成するpingコマンドは単純にICMP Echo 
Requestを1秒間隔で送信して、ICMP Echo Replyを受信したら表示する簡単なプログラムなので安心してください。
（もちろんlibpgenの他の機能を使えば名前解決や他のICMP Typeの解析も行うことができます。）</p>





</div>	
<h2 class="title"><a name=components>libpgenの基本機能</a></h2>
<div>

<p>libpgenは以下の図のようにアドレスクラス、パケットクラス、netutilsの三つで構成されています。</p>
<p>アドレスクラスはネットワークプログラミングでのIPアドレス、MACアドレスの操作に扱いやすいインターフェースを提供します。</p>
<p>パケットクラスはプロトコルごとにパケットを解析したり、自由にパケットを作成したりする作業を簡単に行えるようにします。</p>
<p>netutilsはパケットクラスとOSの橋渡し役として、OSのネットワークを扱って、パケットの送信、受信を担います。
libpgenでは、ネットワークインターフェースに関わる作業を完全に独立させています。リンクレイヤープログラミングの場合、
ソースコードはOSに強く依存するためです。Linuxでのリンクレイヤープログラミングの場合はsocketシステムコールで
PF_PACKETアドレスファミリをしていしてネットワークインターフェースを直接触るのに対して、OSXやBSD系
(厳密にはOSXもBSD系な気がしますが...)のOSではBPF(The Berkeley Packet Filter)をopenシステムコールで開いてネットワーク
インターフェースを触ります。
</p> 

<p>以下ではアドレスクラス、パケットクラス、netutilsについての基本的な使い方をレクチャーしていきます。</p>

<ul>
<li><a href=components/address-class.html>アドレスクラス</a></li>
<li><a href=components/packet-class.html>アドレスクラス</a> </li>
<li><a href=components/netutils.html>アドレスクラス</a>     </li>
</ul>


<p>ここまでの内容で<a href=サンプルプログラム>サンプルプログラム</a>のソースも完全には理解できると思います。次項からは、
libpgenを使った具体的な開発や実験の例を幾つか挙げてそれの説明をしていきます。</p>




</div>	
<h2 class="title"><a name=programing>プログラミングの流れ</a></h2>
<div>

<p>ここでは一般的なlibpgenの使用方法について説明していきます。
libpgenで行うタスクはパケットの作成、編集、送受信、解析です。ここではそれらの方法の基本を説明していきます。</p>


<h3>パケットの作成</h3>
<p>まずは基本中の基本のパケット作成です。パケットを作成するには作成したりプロトコルのパケットクラスのインスタンスを
生成します。</p>

<pre>
	pgen_arp packet;
</pre>

<h3>パケットの編集</h3>

<p>インスタンスを作成したら、パケットを自由に編集します。詳しい編集方法は<a href=プロトコルごとの説明>プロトコルごとの
編集方法</a>を参照してください。<br>以下の例はARPパケットの基本的な編集です。</p>

<pre>
	packet.ETH.src.setmacbydev("wlan0");
	packet.ETH.dst.setbroadcast();
	packet.ARP.srcMac.setmacbydev("wlan0");
	packet.ARP.srcIp.setipbydev("wlan0");
	packet.ARP.dstMac.setbroadcast();
	packet.ARP.dstIp = "192.168.0.1";
	packet.ARP.operation = 2;
</pre>


<h3>パケットの入出力</h3>
<p>libpgenでパケットを入出力する方法はリアルタイム処理をする入出力方法と、処理に時間がかかるが簡単な入出力方法の
2種類があります。</p>
<p>これらの2つの方法の相違点はlibpgen内部でファイルディスクリプタの生存期間の違いです。
これから説明する前者の方法は送信の処理に入ってからファイルディスクリプタを開き、送信が完了すると、そのディスクリプタを
閉じます。このようにすることで、ユーザはファイルディスクリプタの存在を意識することなく直感的に送信を行うことが
できるのです。</p>
<p>これに対して後者の方法は、あらかじめファイルディスクリプタを含むpgenハンドラというイベントハンドラを確保します。
パケットを送受信する場合はそのpgenハンドラを指定して送信を行います。一回一回ディスクリプタを開いたり閉じたりしないので、
処理が高速になり、リアルタイムな処理に適しています。慣れてきたら後者の処理だけで十分でしょう。</p>
<p>まずはそれらの方法について説明していきます。</p>


<h4>パターン1 pgenハンドラを使用しない場合</h4>
<p>この方法ではパケットを送信することのみ許可されています。パケットを受信したり、pcapファイルに読み書きをしたい場合は
パターン2を参照してください。</p>
<p>pgenハンドラを使用しない方法はコードがシンプルで簡単です。ただしかしpingコマンドなど、送信と受信を両方行うプログラムを
書く場合はpgenハンドラを使う方が望ましいので、この方法はお勧めしません。</p>
<h5>パケットを送信</h5>
<p>パケットを送信する方法はじつにシンプルで、パケットクラスのsendメンバ関数を使用するだけです。</p>

<pre>
	pgen_arp packet;
	packet.send("wlan0");
</pre>

詳しくは<a href=パケットクラスの説明>パケットクラスの説明</a>を参照してください。


<h4>パターン2 pgenハンドラを使用する場合</h4>

<h5>pgenハンドラの扱い方</h5>
<p>まずはpgenハンドラの扱い方を習得しましょう。
pgenハンドラはpgen_open関数、pgen_open_offline関数で確保することができます。pgen_open関数はネットワークインターフェース
を扱うハンドラを生成し、pgen_open_offline関数はpcapファイルの読み書きを扱うハンドラを生成します。</p>

<pre>
	pgen_t* onl_handle = pgen_open("wlan0", NULL);
	if(onl_handle == NULL){
		printf("pgen_open erro");
	}
	pgen_t* offl_handle = pgen_open_offline("dumpfile.pcap", 0);
	if(offl_handle == NULL){
		printf("pgen_open erro");
	}
</pre>

<p>ハンドラの確保は成功すると、ハンドラのポインタを返し、失敗するとNULLを返します。</p>
<p>ここまで完了したらあとはパケットを送信するなり、受信するなりpcapファイルに読み書きするなり好きにしてください。
ただし、それらの処理がすべて終了したら、pgenハンドラをpgen_close関数で解放してください。</p>

<pre>
	pgen_close(onl_handle);
	pgen_close(offl_handle);
</pre>


<h5>パケットを送信、またぱpcapファイルに書き込み</h5>
<p>pgenハンドラを確保しているなら、パケットクラスのsend_handleメンバ関数を使用するだけで出力可能です。</p>

<pre>
	pgen_t* onl_handle = pgen_open("wlan0", NULL);
	if(onl_handle == NULL){
		printf("pgen_open erro");
	}

	pgen_arp packet;
	packet.send_handle(onl_handle);

	pgen_close(onl_handle);
</pre>

<p>ハンドラがネットワークインターフェースを操作する状態ならpgen_openで指定したネットワークインターフェースから
パケットが送信されます。また、pcapファイルに書き込む状態ならpgen_open_offlineで指定したファイルにパケットのバイナリが
pcapのファイルフォーマットで書き込まれます。</p>


<h5>パケットを受信、またはpcapファイルから読み込み</h5>
<p>パケットを受信するにはsniff関数を使用します。sniffを使用するためにはpgenハンドラは必要なので、あらかじめ
確保をしておいてください。このときpgen_openでハンドラを確保した場合からは、ネットワークインターフェースから
パケットを入力し、pgen_open_offlineを使用していた場合はpcapファイルからパケットを受信します。</p>

<pre>
	pgen_t* offl_handle = pgen_open_offline("dumpfile.pcap", 0);
	if(offl_handle == NULL){
		printf("pgen_open erro");
	}
	
	sniff(offline_handle, ballbackfunc);
	pgen_close(offl_handle);
</pre>

<p>sniffの詳しい使い方に関しては、<a href>Netutilsの説明</a>を参照してください。</p>



<h3>パケットの解析</h3>
<p>sniffで受信した情報はバイナリ状態なので、簡単に解析をすることができません。
パケットを解析するためにはパケットクラスの形に合わせてやる必要が有ります。
パケットクラスにはcastメンバ関数があるので、それを使ってパケットを解析してやります。</p>

<pre>
	pgen_arp packet;
	packet.cast(buf, len);
</pre>

<p>また、パケットクラスのインスタンスの引数にバイナリの格納アドレスと長さを渡すとインスタンス生成と
同時にcastも行われます。</p>

<pre>
	pgen_arp packet(buf, len);
</pre>

<p>このようにして、パケットクラスに解析させてやれば、簡単にパケットの様々な要素を確認、変更することができます。
編集したパケットを再度、ネットワークインターフェースから送信したり、pcapファイルに書き込むこともできます。</p>




</div>	
<h2 class="title"><a name=extention>拡張する</a></h2>
<div>
<p>現在製作中...</p>





</body></html>
