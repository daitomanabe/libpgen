

<h3>Netutils</h3>
<p>netutilsはパケットクラスとネットワークインタフェースの橋渡しをする役割を持っています。アドレスクラスと
パケットクラスがその名の通りクラスであったのに対して、netutilsは関数群です。ネットワークインターフェースから
パケットを送受信したり、pcapファイルから読み書きしたり(すでにネットワークではなくなってきてるが....)する機能を
提供しています。</p>

<p>以下ではnetutilsに含まれている関数を紹介します。</p>

<pre>
	<b>pgen_t* pgen_open(const char* interface, void* nouse);</b>
	libpgenはpgen_t*という型でネットワークインターフェース、
	ファイル出力やオプションなどを一括管理できるハンドラを
	用意しています。この関数は新たにネットワークインターフェースinterfaceを指定して、
	そのインタフェースから送受信可能なハンドラを確保します。
	第二引数の void* nouseは今後拡張用に用意している引数で、現在は使用できません。

	<b>pgen_t* pgen_open_offline(const char* filename, int mode);</b>
	pgen_openがネットワークインターフェースを扱うハンドラを確保するのに対して、
	pgen_open_offlineはpcapファイルを読み書きするハンドラを確保する関数です。
	第一引数で読み書きするファイル名を相対パス、または絶対パスでしていして、
	第二引数でread onlyかwrite onlyかを指定します。(0: read ,  1: write)
	現在、今後も読み書きの両方を同時に行うモードを追加する予定はありません。

	<b>void pgen_close(pgen_t* handle);</b>
	この関数はpgen_open, pgen_open_offlineで確保したハンドラを解放します。
	プログラムが終了すると確保していたハンドラは自動で解放されますが、
	なるべく確保したハンドラはプログラム内で解放させるようにしてください。

	<b>void sniff(pgen_t* handle, bool (*callback)(const u_char*, int));</b>
	sniffはlibpgenで唯一の受信、読み込みを行う関数です。
	(今後読み込み向け関数を増やしていくかもしれません。)
	もしlibpcapのpcap_loopを使ったことがあるならsniffは限りなくpcap_loopににています。
	sniffは実行されると指定したハンドラhandleの読み込みインタフェース
	(pcapファイルやネットワークインターフェース)からパケットを受信待機します。
	パケットを受信したら、第二引数で指定するコールバック関数に受信したデータ
	(コールバック関数の第一引数)と長さ(コールバック関数の第二引数)を渡して
	コールバック関数を呼び出します。
	コールバック関数を自分で定義して、その関数アドレスをsniffの第二引数に渡すのです。
	コールバック関数のプロトタイプは以下のよう2なります。
		bool callback_function(const u_char buf, int len);
	この関数がtrueを返した場合、sniffはもう一度、受信待機状態に移ります。
	もしfalseが返された場合はsniffの処理はそれで終了し、次の逐次処理を実行します。

	<b>int pgen_sendpacket_handle(pgen_t* handle, const u_char* buf, int len);</b>
	パケットクラスのsend_handleメンバ関数はこのpgen_sendpacket_handleを内部で呼び出して、
	パケットを送信しています。低レイヤネットワークプログラミングをする上で、
	他のOSに移植場合、netutilsだけを切り離して、改造すれば他のOSに
	移植できるようにするために、このように関数を分割しました。

	<b>char* pgen_port2service(int port, int protocol);</b>
	この関数の行うことは実にシンプルです。
	ポート番号とTCPか、UDPかを引数に渡すとそのサービス名をNULLポインタ文字列として返す関数です。
	パケットクラスのinfoメンバ関数などで使用しています。
	またlibpgenを使用して開発を行う時、情報出力をする部分で役に立つはずです。

</pre>
