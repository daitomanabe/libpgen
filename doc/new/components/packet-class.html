

<html >
	<head>
	<title>Packet Class - Libpgen Document</title>	

	<link rel="stylesheet" type="text/css" href="../style.css">
	</head>

		<body>


<h1>パケットクラス</h1>

パケットクラスがlibpgenでもっとも内容が濃く重要なコンポーネントであると言えるでしょう。
このクラスは親のpgen_packetクラスをプロトコルごとに継承してプロトコルごとに一つのクラスを用意してあります。
例えばTCPのパケットを扱いたいならば、対応するパケットクラスはpgen_tcpクラスになるのです。
プロトコルごとの詳しい説明はさておきまずはパケットクラス共通の構造と使用方法を説明していきます。

<h2>クラスの構造</h2>
<p>パケットクラスは大きく分けて次の2つで構成されています。</p>
	<ul>
		<li> プロトコルごとのヘッダやバイナリを格納する配列とその長さ(ようするにメンバ変数) </li>
		<li> パケットのバイナリを生成したり、送信、解析などを行うメンバ関数 </li>
	</ul>

<p>以下ではこれらの2つを説明していく。</p>

<h2>継承関係</h2>
<p>パケットクラス無数にあり、プロトコル1つに対して1つのパケットクラスを用意しています。
これらのクラスはプロトコル階層に合わせて規則的な継承関係を築いています。
2015.09.12現在の継承関係は以下のようになっています。</p>

<pre>
パケットクラスの継承関係

pgen_packet
└── pgen_eth
    ├── pgen_arp
    └── pgen_ip
        ├── pgen_icmp
        ├── pgen_tcp
        └── pgen_udp
            ├── pgen_ardrone
            ├── pgen_dhcp
            └── pgen_dns
</pre>

<p>この図を見てわかる通り、プロトコル構造に合わせて継承関係を築いています。
例えばDHCPのパケットクラスpgen_dhcpならは継承関係は[Ethernet&rarr;IP&rarr;UDP&rarr;DHCP]と継承しているので、
Ethernet, IP, UDPのパケットクラスのメンバ要素も使うことができます。このようにしてlibpgenはソースの重複を少なく
しようとしています。</p>


<h2>メンバ変数</h2>
<p>パケットクラスはプロトコル依存のメンバ変数とプロトコルに依存しないメンバ変数の二種類のメンバ変数を持っています。
ここでは後者のプロトコルに依存しないメンバ変数の紹介を行います。前者のメンバ変数については、
<a href=プロトコルごとの説明>プロトコルごとのパケットクラスの説明</a>を参照してください。</p>

<p>パケットクラスがプロトコルに依存せずに保持するメンバ変数は次の2つだけです。</p>

<pre>
	<b>u_char data[PGEN_MAX_PACKET_LEN];</b>
	compileメンバ関数によって生成されるパケットのバイナリを格納しておく配列。
	complie後にバイナリ解析を行ったりする時にアクセスする場合があります。

	<b>int    len;</b>
	complieで生成されたバイナリの長さが格納される変数。
	dataとセットで使用する。
</pre>



<h2>メンバ関数</h2>
<p>パケットクラスは幾つかのプロトコル共通のメンバ関数を用意しています。
任意のプロトコル専用のメンバ関数も実装されているパケットクラスも存在するのですが、その説明は、
<a href=プロトコルごとの説明>プロトコルごとのパケットクラスの説明</a>を読んでください。 </p>

<p>ではパケットクラス共通のメンバ関数を1つ1つ紹介していきます。</p>

<pre>
	次の6つの関数はプロトコルごとに少し違った動作をしますが、動作目的は同じです

	<b>void clear();</b>
	パケットの各要素をデフォルト値に設定します。大抵のパケットのデフォルト値は
	そのプロトコルで一番よく見かける状態に設定しています。

	<b>void complie();</b>
	パケットクラスの情報から、実際に送信可能なパケットのバイナリを生成します。
	大抵はユーザが呼び出すことはなく、send関数やsummary関数、
	info関数でははじめにこの関数が実行される。

	<b>void cast(const u_char* buf, int len);</b>
	バイナリを解析して、パケットクラスのメンバ変数に反映させる。引数として、
	バイナリの先頭ポインタと長さしか指定しないため、
	実行前に事前にcast関数を実行するパケットクラスのプロトコルであることを確認しておく必要が有る。
	<a href=test>pgen_unknownクラスで、パケットのプロトコルを解析する</a>を参照

	<b>void send(const char* inferface);</b>
	complie関数を実行して、パケットのバイナリを生成して、
	そのパケットを指定したネットワークインターフェースのinterfaceから送信する。
	この関数はプロトコルがEthernet, ARPまでは内部でsend_L2を呼び出して送信をしていて、
	それ以外のプロトコルのクラスはsend_L3で送信をしている。
	もしIP以上のプロトコルでEthernetヘッダまで設定したい場合は
	send_L2関数かsend_handle関数を利用して送信する。

	<b>void summary();</b>
	パケットの情報を1行で簡単に出力する。デバッグや手っ取り早く解析したい時に使用する。
	DHCPのパケットクラスの場合、DHCPの情報のみを出力し、UDPのポート番号やIPアドレスは出力しない。

	<b>void info();</b>
	パケットの情報完全に出力する。
	summary関数が最上位プロトコルのみの出力であったのに対して、
	この関数はすべてのレイヤの情報を細かく出力をする。
	 
	次の2つの関数はどのプロトコルのパケットクラスでも共通の動作を行います

	<b>void hex();</b>
	complie関数でバイナリを生成して、そのバイナリを表示する。
	デバッグなどに使用する。

	<b>void send_L2(const char* interface);</b>
	complie関数でバイナリを生成して、パケットを送信する。
	Ethernetヘッダまでの情報をネットワークインターフェースinterfaceから送信する。
	この関数が実行されると、関数内部で送信用のディスクリプタを確保して、送信後に解放します。
	なので、処理に時間がかかるのでリアルタイムな処理をする場合はsend_handle関数を推奨します。

	<b>void send_L3(const char* interface);</b>
	complie関数でバイナリを生成して、パケットを送信する。
	IPヘッダまでの情報をネットワークインターフェースinterfaceから送信する。
	当たり前だが、EthernetとARPのパケットクラスでは使用できない。
	send_L2同様に関数内部で送信用のディスクリプタを確保して、送信後に解放します。
	なので、処理に時間がかかるのでリアルタイムな処理をする場合はsend_handle関数を推奨します。
	
	<b>void send_handle(pgen_t* handle);</b>
	complie関数でバイナリを生成して、パケットを送信する。
	send_L2やsend_L3と違い、この関数はpgen_open関数などで開いたpgen_t*型の独自のハンドラを指定して
	パケットを送信します。このpgen_t*型のハンドラは内部にディスクリプタを保持していて、
	そのディスクリプタを使用して送信しているので、リアルタイムな処理に適しています。
	
</pre>

<h2><a name=unknown>解析を行うunknownパケット</a></h2>
現在製作中....


<h2><a name=protocol-packet>プロトコルごとのパケットクラス</a></h2>

<p>現在サポートしているプロトコルのパケットクラスは以下の通りです。</p>

<ul>
	<li><a href=./protocols/ethernet.html>Ethernet</a></li>
	<li><a href=./protocols/arp.html>ARP</a></li>
	<li><a href=./protocols/ip.html>IP</a></li>
	<li><a href=./protocols/icmp.html>ICMP</a></li>
	<li><a href=./protocols/tcp.html>TCP</a></li>
	<li><a href=./protocols/udp.html>UDP</a></li>
	<li><a href=./protocols/dns.html>DNS</a></li>
	<li><a href=./protocols/dhcp.html>DHCP</a></li>
	<li><a href=./protocols/http.html>HTTP</a></li>
	<li><a href=./protocols/ardrone.html>ar_drone</a></li>
<ul>




</body></html>
