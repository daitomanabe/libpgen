
<html >
	<head>
	<title>Address Class - Libpgen Document</title>	

	<link rel="stylesheet" type="text/css" href="../style.css">
	</head>

		<body>



<h1>アドレスクラス</h1>
<p>先ほども述べたようにアドレスクラスはIPアドレス、MACアドレスを簡単に表現することができるクラスです。
実際のネットワークプログラミングでは、IPアドレスは32bit符号なし整数。MACアドレスは8bit符号なし整数の長さ6の配列で
表現されています。アドレスクラスはこれらのアドレスのビットフィールドをラッピングして、ユーザの使いやすいインタフェースからの
代入動作などを提供します。
詳しくはlibpgenのソースコードのaddress.hを参照すればより多くの情報を得られます。</p>
<p>アドレスクラスの基本的な使用方法をサンプルコードで示します。</p>

<pre>
	/*
	 * 1. アドレスのインスタンスを生成
	 * 2. インスタンスにアドレスをNULLポインタ文字列から代入
	 *    この時アドレスクラス内部でアドレスのビットフィールドを生成している。
	 * 3. アドレスクラスのメンバ関数c_str()はアドレスの情報を
	 *    NULLポインタ文字列を返すのでそれを使って情報表示
	 */

	/* IPアドレス */
	ipaddr my_ipaddr;
	my_ipaddr = "192.168.0.1";
	printf("my_ipaddr is %s \n", my_ipaddr.c_str()); 

	/* MACアドレス */ 
	macaddr my_macaddr;
	my_macaddr = "00:11:22:33:44:55";
	printf("my_macaddr is %s \n", my_macaddr.c_str()); 
	my_macaddr
</pre>

<p>実行結果は以下のようになります。</p>

<pre>
	my_ipaddr is 192.168.0.1
	my_macaddr is 0:11:22:33:44:55
</pre>


<p>基本的な使用方法はこんな感じです。実際のネットワークプログラミングでは幾つか関数を呼び出したりして、操作をしなくては
いけないのですが、libpgenのアドレスクラスではこのように全てNULLポインタ文字列でアドレス操作をできるようにしています。</p>
<p>基本的な使い方はこれで以上ですが、便利なメンバ関数とオペレータを幾つか用意しているので、そちらの紹介を行います。</p>

<h2>IPアドレス、MACアドレス共通のメンバ関数</h2>
<pre>
	<b>char* c_str(void);</b>
	アドレスをNULLポインタ文字列で返す

	<b>void clear(void);</b>
	アドレスを0クリアする。IPアドレスなら0.0.0.0, 
	MACアドレスなら00:00:00:00:00:00に設定;

	<b>void setOctet(int index, int num);</b>
	アドレスの第indexオクテットの値をnumに設定する。
	IPアドレスは0-3オクテット。MACアドレスは0-5オクテットを指定可能。
	それ以外を指定するとエラー終了をする。
	
	<b>unsigned char getOctet(int index);</b>
	アドレスの第indexオクテットを返す。
	IPアドレスは0-3オクテット。MACアドレスは0-5オクテットを指定可能。
	それ以外を指定するとエラー終了をする。

</pre>

<h2>IPアドレスのみ対応のメンバ関数</h2>
<pre>
	<b>bool setipbydev(const char* interface);</b>
	interfaceのIPアドレスを取得して設定する。成功時はtrueを返し、
	インタフェースが存在しないなどの場合は、
	設定は行われずfalseを返す。

	<b>bool setmaskbydev(const chae* interface);</b>
	interfaceのネットマスクを取得して設定する。成功時はtrueを返し、
	インタフェースが存在しないなどの場合は、
	設定は行われずfalseを返す。

</pre>



<h2>MACアドレスのみ対応のメンバ関数</h2>
<pre>
	<b>bool setmacbydev(const char* interface);</b>
	interfaceのMACアドレスを取得して設定する。成功時はtrueを返し、
	インタフェースが存在しないなどの場合は、設定は行われずfalseを返す。

	<b>bool setmacbroadcast(void);</b>
	MACアドレスをブロードキャストアドレス、
	すなわちff:ff:ff:ff:ff:ffに設定する。
	特に失敗などをすることはないが、trueを返す。

	<b>char* bender(void);</b>
	設定されているMACアドレスの上位3オクテットからアドレスのベンダを
	NULLポインタ文字列で返す。辞書に登録がされていなかったらnot-foundを、
	何かしらのエラーが起きた場合errorを返す。

</pre>



<h2>IPアドレスの対応オペレータ</h2> 
<pre>
	<b>ipaddr& operator=(ipaddr addr);</b>
	通常の代入演算子

	<b>ipaddr& operator=(const char* address_str);</b>
	NULLポインタ文字列からIPアドレスを設定する代入演算子

	<b>ipaddr& operator=(std::string address_str);</b>
	stringクラスのインスタンスからIPアドレスを設定する代入演算子
	
	<b>bool operator&lt;(ipaddr addr);</b>
	大なりの比較演算子。libpgenではIPアドレスでの大小表現を定義しています。
	例えば192.168.0.1 &gt; 192.168.0.5 &rarr; false
	192.168.4.1 &gt; 192.168.0.12 &rarr; true


	<b>bool operator&lt;=(ipaddr addr);</b>
	大なりイコールの比較演算子。評価方法は上に等しい。

	<b>bool operator&gt;(ipaddr addr);</b>
	小なりの比較演算子。評価方法は上に等しい。

	<b>bool operator&gt;=(ipaddr addr);</b>
	小なりイコールの比較演算子。評価方法は上に等しい。
	
	<b>bool operator==(ipaddr addr);</b>
	等価の比較演算子

	<b>bool operator!=(ipaddr addr);</b>
	非等価の比較演算子

	<b>ipaddr& operator++(int);</b>
	IPアドレスのインクリメント用の後置インクリメント演算子。
	192.168.12.4++ &rarr; 192.168.12.5
	10.110.255.255++ &rarr; 10.111.0.0 となる



</pre>

<h2>MACアドレスの対応オペレータ</h2> 
<pre>
	<b>macaddr& operator=(macaddr addr);</b>
	通常の代入演算子

	<b>macaddr& operator=(const char* address_str);</b>
	NULLポインタ文字列からMACアドレスを設定する代入演算子

	<b>macaddr& operator=(std::string address_str);</b>
	stringクラスのインスタンスからMACアドレスを設定する代入演算子
	
	<b>bool operator&lt;(macaddr addr);</b>
	大なりの比較演算子。評価方法はIPアドレスと同じだが、
	MACアドレスの大小比較はほとんど使わないはず。


	<b>bool operator&lt;=(macaddr addr);</b>
	大なりイコールの比較演算子。評価方法は上に等しい。

	<b>bool operator&gt;(macaddr addr);</b>
	小なりの比較演算子。評価方法は上に等しい。

	<b>bool operator&gt;=(macaddr addr);</b>
	小なりイコールの比較演算子。評価方法は上に等しい。
	
	<b>bool operator==(macaddr addr);</b>
	等価の比較演算子

	<b>bool operator!=(macaddr addr);</b>
	非等価の比較演算子


</pre>

以上がアドレスクラスの説明です。このクラスはパケットクラスのアドレス操作やネットワークプログラミングでの
アドレス操作を楽にするだけなので、そこまで複雑ではないので簡単に理解することができるはずです。


</body></html>
